# Building top-level Rust
#
# We build all of the the rust code that is included in lk with a single invocation of make.  Cargo
# does a good job of managing all of the dependencies within Rust (with the main work needed on our
# part are the header files used by bindgen.
#
# In order to allow rust-analyzer to be used naturally, we synthesize the top-level crate that cargo
# builds.  This crate will consist of references to the top-level crates selected to be included in
# the build.

LOCAL_DIR := $(GET_LOCAL_DIR)

# This must match the crate name in the Cargo.toml.
CRATE_NAME := rust_support

MODULE := $(LOCAL_DIR)

MODULES += $(MODULE)

MODULE_SRCDIR := $(MODULE)
MODULE_BUILDDIR := $(call TOBUILDDIR,$(MODULE_SRCDIR))

MODULE_SRCS := \
	       $(MODULE_SRCDIR)/Cargo.toml \
	       $(MODULE_SRCDIR)/src/lib.rs
MODULE_OBJS := $(foreach d,$(MODULE_SRCS),$(call TOBUILDDIR,$(d)))

# USE_RUST can be used by platforms to allow invocation to determine if rust
# support is present. However, when this module is included, we have rust
# support. The define `HAVE_RUST` will indicate that rust is actually being
# used.
HAVE_RUST := 1

GLOBAL_DEFINES += HAVE_RUST=$(HAVE_RUST)

# Modules that contain crates should define ${RUST_CRATES} with a path from the
# build directory to the crate. We make the assumption that the crate name
# matches the directory name.

ifeq ($(RUST_TARGET),)
$(error RUST_TARGET is not set for rust support)
endif

ifeq ($(RUST_TARGET_PATH),)
RUST_TARGET_PATH := $(RUST_TARGET)
endif

define TOML_ESC
$(subst \,\\,$(subst ",\",$1))
endef

CARGO_CONFIG := $(MODULE_BUILDDIR)/.cargo/config.toml

# TODO: Allow debug/release builds
MODULE_OBJECT := $(call TOBUILDDIR,$(MODULE_SRCDIR)/target/$(RUST_TARGET)/debug/lib$(CRATE_NAME).a)

$(MODULE_OBJECT).phony:
.PHONY: $(MODULE_OBJECT).phony

$(MODULE_OBJECT): MODULE_BUILDDIR:=$(MODULE_BUILDDIR)

# Override with module local values for the build rule.
$(MODULE_OBJECT): $(MODULE_OBJECT).phony $(MODULE_OBJS) $(CARGO_CONFIG)
	cd $(MODULE_BUILDDIR); \
		cargo +nightly build

EXTRA_OBJS := $(EXTRA_OBJS) $(MODULE_OBJECT)

# Bring in the source files via copy.
# The toml file will have a substitution to fix up references to the buildroot.
$(MODULE_BUILDDIR)/%: MODULE_SRCDIR:=$(MODULE_SRCDIR)

$(MODULE_BUILDDIR)/%: $(MODULE_SRCDIR)/%.in target.phony
	$(NOECHO)echo generating $@
	$(NOECHO)mkdir -p $(dir $@)
	$(NOECHO)env \
		BUILDROOT="$(abspath $(BUILDROOT))" \
		RUST_CRATES="$(RUST_CRATES)" \
	        python3 $(MODULE_SRCDIR)/expand.py $< > $@.tmp
	$(NOECHO)$(call TESTANDREPLACEFILE,$@.tmp,$@)

.PHONY: target.phony

$(CARGO_CONFIG).phony:
.PHONY: $(CARGO_CONFIG).phony

$(CARGO_CONFIG): MODULE_SRCDIR:=$(MODULE_SRCDIR)

$(CARGO_CONFIG): $(CARGO_CONFIG).phony
	$(NOECHO)mkdir -p $(dir $@)
	$(NOECHO)tmp="$@.tmp"; { \
		echo "# AUTOGENERATED -- edit $(MODULE_SRCDIR)/rules.mk instead"; \
		echo "[build]"; \
		echo 'target = "$(RUST_TARGET_PATH)"'; \
		echo; \
		echo "[env]"; \
		echo 'GLOBAL_INCLUDES = { value = "$(call TOML_ESC,$(GLOBAL_INCLUDES))", force = true }'; \
		echo; \
		echo "[unstable]"; \
		echo 'build-std = ["core", "alloc"]'; \
	} > "$$tmp"; \
	$(call TESTANDREPLACEFILE,$$tmp,$@)

MODULE :=
MODULE_SRCDIR :=
MODULE_BUILDDIR :=
MODULE_OBJECT :=
MODULE_SRCS :=
MODULE_OBJS :=

CARGO_CONFIG :=
